{"version":3,"sources":["../src/index.ts","../src/response-error.ts","../src/validation-error.ts","../src/utils.ts","../src/fallback-options.ts","../src/stream.ts","../src/up.ts"],"sourcesContent":["export { up } from './up'\nexport type { FetcherOptions, DefaultOptions, RetryOptions } from './types'\nexport { ResponseError, isResponseError } from './response-error'\nexport { type ValidationError, isValidationError } from './validation-error'\nexport { isJsonifiable } from './utils'\nexport type { StandardSchemaV1 } from '@standard-schema/spec'\n","export class ResponseError<TData = any> extends Error {\n   override name: 'ResponseError'\n   response: Response\n   request: Request\n   data: TData\n   status: number\n\n   constructor(res: Response, data: TData, request: Request) {\n      super(`[${res.status}] ${res.statusText}`)\n      this.data = data\n      this.name = 'ResponseError'\n      this.response = res\n      this.status = res.status\n      this.request = request\n   }\n}\n\nexport const isResponseError = <TData = any>(\n   error: unknown,\n): error is ResponseError<TData> => error instanceof ResponseError\n","import type { StandardSchemaV1 } from '@standard-schema/spec'\n\nexport class ValidationError<TData = any> extends Error {\n   override name: 'ValidationError'\n   issues: readonly StandardSchemaV1.Issue[]\n   data: TData\n\n   constructor(result: StandardSchemaV1.FailureResult, data: TData) {\n      super(JSON.stringify(result.issues))\n      this.name = 'ValidationError'\n      this.issues = result.issues\n      this.data = data\n   }\n}\n\nexport const isValidationError = (error: unknown): error is ValidationError =>\n   error instanceof ValidationError\n","import type { StandardSchemaV1 } from '@standard-schema/spec'\nimport type {\n   DistributiveOmit,\n   JsonifiableArray,\n   JsonifiableObject,\n   KeyOf,\n   Params,\n   RawHeaders,\n   SerializeParams,\n} from './types'\nimport { ValidationError } from './validation-error'\n\nexport const mergeHeaders = (headerInits: (RawHeaders | undefined)[]) => {\n   const res: Record<string, string> = {}\n   headerInits.forEach((init) => {\n      // casting `init` to `HeadersInit` because `Record<string, any>` is\n      // properly transformed to `Record<string,string>` by `new Headers(init)`\n      new Headers(init as HeadersInit | undefined).forEach((value, key) => {\n         value === 'null' || value === 'undefined'\n            ? delete res[key]\n            : (res[key] = value)\n      })\n   })\n   return res\n}\n\nexport const withTimeout = (\n   signal: AbortSignal | undefined,\n   timeout: number | undefined,\n): AbortSignal | undefined =>\n   // if AbortSignal.any is not supported\n   // AbortSignal.timeout is not supported either.\n   // Feature detection is fine on AbortSignal.any only\n   'any' in AbortSignal\n      ? AbortSignal.any(\n           [signal, timeout && AbortSignal.timeout(timeout)].filter(\n              Boolean,\n           ) as AbortSignal[],\n        )\n      : signal\n\nexport const omit = <O extends object, K extends KeyOf<O> | (string & {})>(\n   obj?: O,\n   keys: K[] | readonly K[] = [],\n): DistributiveOmit<O, K> => {\n   const copy = { ...obj } as DistributiveOmit<O, K>\n   for (const key in copy) {\n      keys.includes(key as any) && delete copy[key]\n   }\n   return copy\n}\n\nexport const isJsonifiable = (\n   value: any,\n): value is JsonifiableObject | JsonifiableArray =>\n   isPlainObject(value) ||\n   Array.isArray(value) ||\n   typeof value?.toJSON === 'function'\n\nconst isPlainObject = (value: any): value is Record<string, any> =>\n   value && typeof value === 'object' && value.constructor?.name === 'Object'\n\nexport const resolveUrl = (\n   base: string | undefined = '',\n   input: URL | string,\n   defaultOptsParams: Params | undefined,\n   fetcherOptsParams: Params | undefined,\n   serializeParams: SerializeParams,\n): string => {\n   input = (input as URL).href ?? input\n   const qs = serializeParams({\n      // Removing the 'url.searchParams.keys()' from the defaultParams\n      // but not from the 'fetcherParams'. The user is responsible for not\n      // specifying the params in both the \"input\" and the fetcher \"params\" option.\n      ...omit(defaultOptsParams, [\n         ...new URL(input, 'http://a').searchParams.keys(),\n      ]),\n      ...fetcherOptsParams,\n   })\n\n   let url: string = /^https?:\\/\\//.test(input)\n      ? input\n      : !base || !input\n        ? base + input\n        : base.replace(/\\/$/, '') + '/' + input.replace(/^\\//, '')\n\n   if (qs) {\n      url += (url.includes('?') ? '&' : '?') + qs.replace(/^\\?/, '')\n   }\n   return url\n}\n\nexport const abortableDelay = (delay: number, signal?: AbortSignal) =>\n   new Promise<void>((resolve, reject) => {\n      signal?.addEventListener('abort', handleAbort, { once: true })\n\n      const token = setTimeout(() => {\n         signal?.removeEventListener('abort', handleAbort)\n         resolve()\n      }, delay)\n\n      function handleAbort() {\n         clearTimeout(token)\n         reject(signal!.reason)\n      }\n   })\n\nexport async function validate<TSchema extends StandardSchemaV1>(\n   schema: TSchema,\n   data: StandardSchemaV1.InferInput<TSchema>,\n): Promise<StandardSchemaV1.InferOutput<TSchema>> {\n   const result = await schema['~standard'].validate(data)\n   if (result.issues) throw new ValidationError(result, data)\n   return result.value\n}\n","import { ResponseError } from './response-error'\nimport type { FallbackOptions } from './types'\nimport { isJsonifiable } from './utils'\n\nexport const fallbackOptions: FallbackOptions = {\n   parseResponse: (res) =>\n      res\n         .clone()\n         .json()\n         .catch(() => res.text())\n         .then((data) => data || null),\n\n   parseRejected: async (res, request) =>\n      new ResponseError(\n         res,\n         await fallbackOptions.parseResponse(res, request),\n         request,\n      ),\n\n   // TODO: find a lighter way to do this with about the same amount of code\n   serializeParams: (params) =>\n      // JSON.parse(JSON.stringify(params)) recursively transforms Dates to ISO strings and strips undefined\n      new URLSearchParams(\n         JSON.parse(JSON.stringify(params)) as Record<string, string>,\n      ).toString(),\n\n   serializeBody: (body: any) =>\n      isJsonifiable(body) ? JSON.stringify(body) : body,\n\n   reject: (response) => !response.ok,\n\n   retry: {\n      when: (ctx) => ctx.response?.ok === false,\n      attempts: 0,\n      delay: 0,\n   },\n}\n","import type { StreamingEvent } from './types'\n\nexport async function toStreamable<R extends Request | Response>(\n   reqOrRes: R,\n   onStream?: (event: StreamingEvent, reqOrRes: R) => void,\n): Promise<R> {\n   const isResponse = 'ok' in reqOrRes\n   const body: (Request | Request)['body'] =\n      reqOrRes.body || (reqOrRes as any)._bodyInit\n   if (!onStream || !body) return reqOrRes\n   const contentLength = reqOrRes.headers.get('content-length')\n   let totalBytes: number = +(contentLength || 0)\n   // For the Request, when no \"Content-Length\" header is present, we read the total bytes from the body\n   if (!isResponse && !contentLength) {\n      for await (const chunk of reqOrRes.clone().body!) {\n         totalBytes += chunk.byteLength\n      }\n   }\n\n   let transferredBytes = 0\n   onStream({ totalBytes, transferredBytes, chunk: new Uint8Array() }, reqOrRes)\n\n   const stream = new ReadableStream({\n      async start(controller) {\n         for await (const chunk of reqOrRes.body!) {\n            transferredBytes += chunk.byteLength\n            totalBytes = Math.max(totalBytes, transferredBytes)\n            onStream({ totalBytes, transferredBytes, chunk }, reqOrRes)\n            controller.enqueue(chunk)\n         }\n         controller.close()\n      },\n   })\n\n   return isResponse\n      ? (new Response(stream, reqOrRes) as R)\n      : // @ts-expect-error outdated ts types\n        (new Request(reqOrRes, { body: stream, duplex: 'half' }) as R)\n}\n","import { fallbackOptions } from './fallback-options'\nimport { toStreamable } from './stream'\nimport type {\n   BaseFetchFn,\n   DefaultOptions,\n   DefaultRawBody,\n   DistributiveOmit,\n   FetcherOptions,\n   MaybePromise,\n   RetryContext,\n   UpFetch,\n} from './types'\nimport {\n   abortableDelay,\n   isJsonifiable,\n   mergeHeaders,\n   omit,\n   resolveUrl,\n   validate,\n   withTimeout,\n} from './utils'\n\nconst emptyOptions = {} as any\n\nexport const up =\n   <\n      TFetchFn extends BaseFetchFn,\n      TDefaultParsedData = any,\n      TDefaultRawBody = DefaultRawBody,\n   >(\n      fetchFn: TFetchFn,\n      getDefaultOptions: (\n         input: Exclude<Parameters<TFetchFn>[0], Request>,\n         fetcherOpts: FetcherOptions<TFetchFn, any, any, any>,\n         ctx?: Parameters<TFetchFn>[2],\n      ) => MaybePromise<\n         DefaultOptions<TFetchFn, TDefaultParsedData, TDefaultRawBody>\n      > = () => emptyOptions,\n   ): UpFetch<TDefaultParsedData, TDefaultRawBody, TFetchFn> =>\n   async (input, fetcherOpts = emptyOptions, ctx) => {\n      const defaultOpts = await getDefaultOptions(input, fetcherOpts, ctx)\n\n      const options = {\n         ...fallbackOptions,\n         ...defaultOpts,\n         ...fetcherOpts,\n         ...(emptyOptions as { body: BodyInit | null | undefined }),\n         retry: {\n            ...fallbackOptions.retry,\n            ...defaultOpts.retry,\n            ...fetcherOpts.retry,\n         },\n      }\n\n      // merge event handlers\n      Object.keys(defaultOpts).forEach((key) => {\n         if (/^on[A-Z]/.test(key)) {\n            ;(options as any)[key] = (...args: unknown[]) => {\n               defaultOpts[key]?.(...args)\n               fetcherOpts[key]?.(...args)\n            }\n         }\n      })\n\n      options.body =\n         fetcherOpts.body === null || fetcherOpts.body === undefined\n            ? (fetcherOpts.body as null | undefined)\n            : options.serializeBody(fetcherOpts.body)\n\n      options.headers = mergeHeaders([\n         isJsonifiable(fetcherOpts.body) && typeof options.body === 'string'\n            ? { 'content-type': 'application/json' }\n            : {},\n         defaultOpts.headers,\n         fetcherOpts.headers,\n      ])\n\n      let attempt = 0\n      let request: Request | undefined = undefined;\n\n      const outcome = {} as DistributiveOmit<RetryContext, 'request'>\n      try {\n         do {\n            // per-try timeout\n            options.signal = withTimeout(fetcherOpts.signal, options.timeout)\n\n            request = await toStreamable(\n               new Request(\n                  input.url\n                     ? input // Request\n                     : resolveUrl(\n                          options.baseUrl,\n                          input, // string | URL\n                          defaultOpts.params,\n                          fetcherOpts.params,\n                          options.serializeParams,\n                       ),\n                  options,\n               ),\n               options.onRequestStreaming,\n            )\n            options.onRequest?.(request)\n\n            try {\n               outcome.response = await toStreamable(\n                  await fetchFn(\n                     request,\n                     // do not override the request body & patch headers again\n                     { ...omit(options, ['body']), headers: request.headers },\n                     ctx,\n                  ),\n                  options.onResponseStreaming,\n               )\n            } catch (e: any) {\n               outcome.error = e\n            }\n\n            if (\n               !(await options.retry.when({ request, ...outcome })) ||\n               ++attempt >\n                  (typeof options.retry.attempts === 'function'\n                     ? await options.retry.attempts({ request })\n                     : options.retry.attempts)\n            )\n               break\n\n            await abortableDelay(\n               typeof options.retry.delay === 'function'\n                  ? await options.retry.delay({ attempt, request, ...outcome })\n                  : options.retry.delay,\n               options.signal,\n            )\n            options.onRetry?.({ attempt, request, ...outcome })\n            // biome-ignore lint/correctness/noConstantCondition: <explanation>\n         } while (true)\n\n         if (outcome.error) {\n            throw outcome.error\n         }\n         const response = outcome.response as Response\n\n         if (!(await options.reject(response))) {\n            let parsed: any\n            try {\n               parsed = await options.parseResponse(response, request)\n            } catch (error: any) {\n               throw error\n            }\n            let data: any\n            try {\n               data = options.schema\n                  ? await validate(options.schema, parsed)\n                  : parsed\n            } catch (error: any) {\n               throw error\n            }\n            options.onSuccess?.(data, request)\n            return data\n         }\n         let respError: any\n         try {\n            respError = await options.parseRejected(response, request)\n         } catch (error: any) {\n            throw error\n         }\n         throw respError\n      } catch (error: any) {\n         const cstError = options.parseError?.(error, request)\n         options.onError?.(cstError ?? error, request)\n         throw cstError ?? error\n      }\n   }\n"],"mappings":"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","names":["src_exports","__export","ResponseError","isJsonifiable","isResponseError","isValidationError","up","__toCommonJS","ResponseError","res","data","request","isResponseError","error","ValidationError","result","data","isValidationError","error","mergeHeaders","headerInits","res","init","value","key","withTimeout","signal","timeout","omit","obj","keys","copy","isJsonifiable","isPlainObject","resolveUrl","base","input","defaultOptsParams","fetcherOptsParams","serializeParams","qs","url","abortableDelay","delay","resolve","reject","handleAbort","token","validate","schema","data","result","ValidationError","fallbackOptions","res","data","request","ResponseError","params","body","isJsonifiable","response","ctx","toStreamable","reqOrRes","onStream","isResponse","body","contentLength","totalBytes","chunk","transferredBytes","stream","controller","emptyOptions","up","fetchFn","getDefaultOptions","input","fetcherOpts","ctx","defaultOpts","options","fallbackOptions","key","args","mergeHeaders","isJsonifiable","attempt","request","outcome","withTimeout","toStreamable","resolveUrl","omit","e","abortableDelay","response","parsed","error","data","validate","respError","cstError"]}